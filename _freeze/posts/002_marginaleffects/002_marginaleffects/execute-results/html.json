{
  "hash": "f769d3b69fcc2773f437ff0e0c37194c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Computing predictions for multilevel models with the marginaleffects package\"\ndescription: \"How to compute predictions and making inferences for different estimands in Generalized Linear Mixed Models, using the lme4, brms, and marginaleffects R packages.\"\ndate: 2024-05-28\ncategories: [\"marginaleffects\", \"brms\", \"lme4\", \"multilevel model\", \"estimand\"]\nnumber-sections: true\ndf-print: kable\ncode-overflow: scroll\ncode-link: true\n---\n\n\n:::{.callout-tip}\n# In this post\n\nIn the past, I have used the [multcomp](https://cran.r-project.org/web/packages/multcomp/index.html) package to compute inferences for my statistical models in R. However, the [marginaleffects](https://cran.r-project.org/web/packages/marginaleffects/index.html) package seems to be the new kid in town, and I wanted to learn how it works. In this post, I tried to familiarize myself with the *marginaleffects* syntax to compute different statistical estimands for multilevel models fitted with the [lme4](https://cran.r-project.org/web/packages/lme4/index.html) and [brms](https://cran.r-project.org/web/packages/brms/index.html) packages.\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(lme4)\nlibrary(brms)\nlibrary(marginaleffects)\n```\n:::\n\n\n## Simulate multilevel data\n\nI will use simulated data from a *Generalized Linear Mixed Model* (GLMM) in this post. The simulation code was inspired by the [online documentation of the faux R package](https://debruine.github.io/faux/articles/sim_mixed.html#simulating-data).\nFor this example, imagine that `n_subjects` subjects respond to `n_items` stimuli in a diagnostic decision task. The binary response variable `y_bin` reflects whether the diagnostic decision is correct or not. For some trials, the participants are presented with advice (`advice_present` = 1) that should help them making the correct diagnostic decision.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimulate <- function(n_subjects = 100, n_items = 50,\n  b_0 = 0.8, b_a = 1,\n  sd_u0s = 0.5, sd_u0i = 0.5, sd_u1s = 0.5, ...){\n  require(dplyr)\n  require(faux)\n  # simulate design\n  dat <- add_random(subject = n_subjects, item = n_items) %>%\n    mutate(advice_present = rbinom(n(), 1, prob = 2/3)) %>%\n    # add random effects\n    add_ranef(\"subject\", u0s = sd_u0s) %>%#\n    add_ranef(\"subject\", u1s = sd_u1s) %>%\n    add_ranef(\"item\", u0i = sd_u0i) %>%\n    # compute dependent variable\n    mutate(linpred = b_0 + u0i + u0s +\n        (b_a + u1s) * advice_present) %>%\n    mutate(y_prob = plogis(linpred)) %>%\n    mutate(y_bin = rbinom(n = n(), size = 1, prob = y_prob))\n  dat\n}\n\nset.seed(1)\ndat <- simulate()\n```\n:::\n\n\n## Fit multilevel models\n\nI will fit a multilevel model with both the *lme4* and the *brms* package.\nThe specified model is equal to the *true* model from which the data have been simulated.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- y_bin ~ 1 + advice_present +\n  (1 + advice_present || subject) + (1|item)\n\nfit_lme4 <- glmer(f, data = dat, family = \"binomial\")\nset.seed(1)\nfit_brms <- brm(f, data = dat, family = \"bernoulli\", \n  backend = \"cmdstanr\",\n  chains = 4, cores = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRunning MCMC with 4 parallel chains...\n\nChain 1 Iteration:    1 / 2000 [  0%]  (Warmup) \nChain 2 Iteration:    1 / 2000 [  0%]  (Warmup) \nChain 3 Iteration:    1 / 2000 [  0%]  (Warmup) \nChain 4 Iteration:    1 / 2000 [  0%]  (Warmup) \nChain 2 Iteration:  100 / 2000 [  5%]  (Warmup) \nChain 4 Iteration:  100 / 2000 [  5%]  (Warmup) \nChain 3 Iteration:  100 / 2000 [  5%]  (Warmup) \nChain 1 Iteration:  100 / 2000 [  5%]  (Warmup) \nChain 2 Iteration:  200 / 2000 [ 10%]  (Warmup) \nChain 3 Iteration:  200 / 2000 [ 10%]  (Warmup) \nChain 1 Iteration:  200 / 2000 [ 10%]  (Warmup) \nChain 2 Iteration:  300 / 2000 [ 15%]  (Warmup) \nChain 3 Iteration:  300 / 2000 [ 15%]  (Warmup) \nChain 4 Iteration:  200 / 2000 [ 10%]  (Warmup) \nChain 1 Iteration:  300 / 2000 [ 15%]  (Warmup) \nChain 2 Iteration:  400 / 2000 [ 20%]  (Warmup) \nChain 3 Iteration:  400 / 2000 [ 20%]  (Warmup) \nChain 1 Iteration:  400 / 2000 [ 20%]  (Warmup) \nChain 4 Iteration:  300 / 2000 [ 15%]  (Warmup) \nChain 2 Iteration:  500 / 2000 [ 25%]  (Warmup) \nChain 3 Iteration:  500 / 2000 [ 25%]  (Warmup) \nChain 4 Iteration:  400 / 2000 [ 20%]  (Warmup) \nChain 1 Iteration:  500 / 2000 [ 25%]  (Warmup) \nChain 2 Iteration:  600 / 2000 [ 30%]  (Warmup) \nChain 3 Iteration:  600 / 2000 [ 30%]  (Warmup) \nChain 4 Iteration:  500 / 2000 [ 25%]  (Warmup) \nChain 2 Iteration:  700 / 2000 [ 35%]  (Warmup) \nChain 3 Iteration:  700 / 2000 [ 35%]  (Warmup) \nChain 1 Iteration:  600 / 2000 [ 30%]  (Warmup) \nChain 4 Iteration:  600 / 2000 [ 30%]  (Warmup) \nChain 2 Iteration:  800 / 2000 [ 40%]  (Warmup) \nChain 3 Iteration:  800 / 2000 [ 40%]  (Warmup) \nChain 4 Iteration:  700 / 2000 [ 35%]  (Warmup) \nChain 1 Iteration:  700 / 2000 [ 35%]  (Warmup) \nChain 2 Iteration:  900 / 2000 [ 45%]  (Warmup) \nChain 3 Iteration:  900 / 2000 [ 45%]  (Warmup) \nChain 4 Iteration:  800 / 2000 [ 40%]  (Warmup) \nChain 2 Iteration: 1000 / 2000 [ 50%]  (Warmup) \nChain 2 Iteration: 1001 / 2000 [ 50%]  (Sampling) \nChain 3 Iteration: 1000 / 2000 [ 50%]  (Warmup) \nChain 3 Iteration: 1001 / 2000 [ 50%]  (Sampling) \nChain 1 Iteration:  800 / 2000 [ 40%]  (Warmup) \nChain 4 Iteration:  900 / 2000 [ 45%]  (Warmup) \nChain 2 Iteration: 1100 / 2000 [ 55%]  (Sampling) \nChain 3 Iteration: 1100 / 2000 [ 55%]  (Sampling) \nChain 1 Iteration:  900 / 2000 [ 45%]  (Warmup) \nChain 2 Iteration: 1200 / 2000 [ 60%]  (Sampling) \nChain 4 Iteration: 1000 / 2000 [ 50%]  (Warmup) \nChain 4 Iteration: 1001 / 2000 [ 50%]  (Sampling) \nChain 3 Iteration: 1200 / 2000 [ 60%]  (Sampling) \nChain 1 Iteration: 1000 / 2000 [ 50%]  (Warmup) \nChain 1 Iteration: 1001 / 2000 [ 50%]  (Sampling) \nChain 2 Iteration: 1300 / 2000 [ 65%]  (Sampling) \nChain 4 Iteration: 1100 / 2000 [ 55%]  (Sampling) \nChain 3 Iteration: 1300 / 2000 [ 65%]  (Sampling) \nChain 2 Iteration: 1400 / 2000 [ 70%]  (Sampling) \nChain 1 Iteration: 1100 / 2000 [ 55%]  (Sampling) \nChain 3 Iteration: 1400 / 2000 [ 70%]  (Sampling) \nChain 4 Iteration: 1200 / 2000 [ 60%]  (Sampling) \nChain 1 Iteration: 1200 / 2000 [ 60%]  (Sampling) \nChain 2 Iteration: 1500 / 2000 [ 75%]  (Sampling) \nChain 4 Iteration: 1300 / 2000 [ 65%]  (Sampling) \nChain 3 Iteration: 1500 / 2000 [ 75%]  (Sampling) \nChain 1 Iteration: 1300 / 2000 [ 65%]  (Sampling) \nChain 2 Iteration: 1600 / 2000 [ 80%]  (Sampling) \nChain 4 Iteration: 1400 / 2000 [ 70%]  (Sampling) \nChain 3 Iteration: 1600 / 2000 [ 80%]  (Sampling) \nChain 1 Iteration: 1400 / 2000 [ 70%]  (Sampling) \nChain 2 Iteration: 1700 / 2000 [ 85%]  (Sampling) \nChain 4 Iteration: 1500 / 2000 [ 75%]  (Sampling) \nChain 3 Iteration: 1700 / 2000 [ 85%]  (Sampling) \nChain 1 Iteration: 1500 / 2000 [ 75%]  (Sampling) \nChain 2 Iteration: 1800 / 2000 [ 90%]  (Sampling) \nChain 3 Iteration: 1800 / 2000 [ 90%]  (Sampling) \nChain 4 Iteration: 1600 / 2000 [ 80%]  (Sampling) \nChain 2 Iteration: 1900 / 2000 [ 95%]  (Sampling) \nChain 1 Iteration: 1600 / 2000 [ 80%]  (Sampling) \nChain 4 Iteration: 1700 / 2000 [ 85%]  (Sampling) \nChain 3 Iteration: 1900 / 2000 [ 95%]  (Sampling) \nChain 2 Iteration: 2000 / 2000 [100%]  (Sampling) \nChain 1 Iteration: 1700 / 2000 [ 85%]  (Sampling) \nChain 4 Iteration: 1800 / 2000 [ 90%]  (Sampling) \nChain 2 finished in 35.7 seconds.\nChain 3 Iteration: 2000 / 2000 [100%]  (Sampling) \nChain 3 finished in 35.8 seconds.\nChain 1 Iteration: 1800 / 2000 [ 90%]  (Sampling) \nChain 4 Iteration: 1900 / 2000 [ 95%]  (Sampling) \nChain 1 Iteration: 1900 / 2000 [ 95%]  (Sampling) \nChain 4 Iteration: 2000 / 2000 [100%]  (Sampling) \nChain 4 finished in 37.4 seconds.\nChain 1 Iteration: 2000 / 2000 [100%]  (Sampling) \nChain 1 finished in 38.2 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 36.8 seconds.\nTotal execution time: 38.3 seconds.\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(fit_lme4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGeneralized linear mixed model fit by maximum likelihood (Laplace\n  Approximation) [glmerMod]\n Family: binomial  ( logit )\nFormula: y_bin ~ 1 + advice_present + (1 + advice_present || subject) +  \n    (1 | item)\n   Data: dat\n\n     AIC      BIC   logLik deviance df.resid \n  4997.9   5030.5  -2494.0   4987.9     4995 \n\nScaled residuals: \n    Min      1Q  Median      3Q     Max \n-5.4937  0.2292  0.3969  0.5510  1.4685 \n\nRandom effects:\n Groups    Name           Variance Std.Dev.\n subject   (Intercept)    0.2173   0.4661  \n subject.1 advice_present 0.2519   0.5018  \n item      (Intercept)    0.1949   0.4415  \nNumber of obs: 5000, groups:  subject, 100; item, 50\n\nFixed effects:\n               Estimate Std. Error z value Pr(>|z|)    \n(Intercept)     0.75270    0.09540    7.89 3.03e-15 ***\nadvice_present  1.02600    0.09085   11.29  < 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nCorrelation of Fixed Effects:\n            (Intr)\nadvic_prsnt -0.339\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(fit_brms)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Family: bernoulli \n  Links: mu = logit \nFormula: y_bin ~ 1 + advice_present + (1 + advice_present || subject) + (1 | item) \n   Data: dat (Number of observations: 5000) \n  Draws: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;\n         total post-warmup draws = 4000\n\nMultilevel Hyperparameters:\n~item (Number of levels: 50) \n              Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsd(Intercept)     0.46      0.06     0.35     0.60 1.00     1318     1884\n\n~subject (Number of levels: 100) \n                   Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsd(Intercept)          0.48      0.07     0.36     0.62 1.01     1248     2241\nsd(advice_present)     0.53      0.10     0.33     0.72 1.00      899     1800\n\nRegression Coefficients:\n               Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nIntercept          0.75      0.10     0.56     0.94 1.00     1682     2416\nadvice_present     1.03      0.10     0.85     1.23 1.00     2441     2573\n\nDraws were sampled using sample(hmc). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).\n```\n\n\n:::\n:::\n\n\nWhen looking at the model outputs, we can see that both models have very similar parameter estimates, and parameter estimates closely match the true values we specified in the simulation. The diagnostics of the brms model (Rhats < 0, decent ESS, and no divergent transitions) suggest that the model is identified and has successfully converged, which is what we expect when fitting the *true* model to a large enough sample.\n\n## Estimate different contrasts with marginaleffects\n\nIn the following sections, I compute predictions from these models with the *marginaleffects* package and estimate contrasts for different estimands. There are usually several different ways how to compute the same estimates with *marginaleffects*, and I will convince myself that they produce similar results. Great resources on these topics are the [documentation of the marginaleffects package](https://marginaleffects.com/vignettes/brms.html#random-effects-model), as well as the excellent blog-posts ([1](https://www.andrewheiss.com/blog/2022/05/20/marginalia/), [2](https://www.andrewheiss.com/blog/2022/11/29/conditional-marginal-marginaleffects/), [3](https://www.andrewheiss.com/blog/2023/08/12/conjoint-multilevel-multinomial-guide/)) by [Andrew Heiss](https://www.andrewheiss.com/).\n\n### Some important function arguments and options in marginaleffects\n\n::: {.callout-important}\nWhen using the `datagrid` function inside one of the many *marginaleffects* functions, be aware that by default **all variables not explicitly specified are set to the mean or mode** (depending on the variable type). Better check the result of `datagrid` to make sure you know which predictor values your predictions are actually based on!\n:::\n\n::: {.callout-important}\nWhen using `type = response` in *marginaleffects* for multilevel models fitted with *lme4* or *brms*, this will produce estimates for the conditional expected value of the response $E(Y|x, u)$ (and does *not* simulate individual response values from the posterior predictive distribution). \n:::\n\n::: {.callout-important}\nBy default, *marginaleffects* averages the posterior draws of *brms* models using the median. However, we might prefer using the mean to assure that the order of aggregation does not matter.\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(marginaleffects_posterior_center = mean)\noptions(marginaleffects_posterior_interval = \"eti\")\n```\n:::\n\nThe other option specifies the type of posterior intervals (equal-tailed intervals vs. highest density intervals). We use the default `\"eti\"` but list this option here as a reminder that it exist.\n:::\n\n\n\n\n### Treatment effect for an average person and an average item\n\n**Estimand:**\n\n$$\n\\begin{aligned}\n& P(Y = 1 | advice\\_present = 1, u_{0s} = 0, u_{1s} = 0, u_{0i} = 0) \\\\\n& \\quad - P(Y = 1 | advice\\_present = 0, u_{0s} = 0, u_{1s} = 0, u_{0i} = 0)\n\\end{aligned}\n$$\n\n#### lme4\n\n::: {.callout-important}\nThe option `re.form = NA` specifies that all random effects are set to 0 when computing predictions. The option `re.form = NULL` specifies that all random effects are always included.\n:::\n\n::: {.panel-tabset group=\"package1\"}\n\n## Option 1\n\n\n::: {.cell}\n\n```{.r .cell-code}\navg_predictions(fit_lme4, \n  variables = list(advice_present = 0:1), \n  re.form = NA, type = \"response\") %>% \n  hypotheses(hypothesis = c(\"b2 - b1 = 0\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n    Term Estimate Std. Error    z Pr(>|z|)    S 2.5 % 97.5 %\n b2-b1=0    0.176     0.0166 10.6   <0.001 84.8 0.143  0.208\n\nColumns: term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \nType:  response \n```\n\n\n:::\n:::\n\n\n## Option 2\n\n\n::: {.cell}\n\n```{.r .cell-code}\navg_comparisons(fit_lme4, \n  variables = \"advice_present\", \n  re.form = NA, type = \"response\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n           Term          Contrast Estimate Std. Error    z Pr(>|z|)    S 2.5 %\n advice_present mean(1) - mean(0)    0.176     0.0166 10.6   <0.001 84.8 0.143\n 97.5 %\n  0.208\n\nColumns: term, contrast, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high, predicted_lo, predicted_hi, predicted \nType:  response \n```\n\n\n:::\n:::\n\n\n## Option 3\n\n\n::: {.cell}\n\n```{.r .cell-code}\npredictions(fit_lme4,\n  newdata = datagrid(advice_present = 0:1),\n  re.form = NA, type = \"response\") %>% \n  hypotheses(hypothesis = c(\"b2 - b1 = 0\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n    Term Estimate Std. Error    z Pr(>|z|)    S 2.5 % 97.5 %\n b2-b1=0    0.176     0.0166 10.6   <0.001 84.8 0.143  0.208\n\nColumns: term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \nType:  response \n```\n\n\n:::\n:::\n\n\n## Option 4\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncomparisons(fit_lme4,\n  newdata = datagrid(advice_present = 1),\n  re.form = NA, type = \"response\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n           Term Contrast advice_present Estimate Std. Error    z Pr(>|z|)    S\n advice_present    1 - 0              1    0.176     0.0166 10.6   <0.001 84.8\n 2.5 % 97.5 %    subject   item\n 0.143  0.208 subject001 item01\n\nColumns: rowid, term, contrast, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high, advice_present, predicted_lo, predicted_hi, predicted, subject, item, y_bin \nType:  response \n```\n\n\n:::\n:::\n\n\n:::\n\n\n#### brms\n\n::: {.callout-important}\nThe option `re_formula = NA` specifies that all random effects are set to 0 when computing predictions. The option `re_formula = NULL` specifies that all random effects are always included.\n:::\n\n::: {.panel-tabset group=\"package1\"}\n\n## Option 1\n\n\n::: {.cell}\n\n```{.r .cell-code}\navg_predictions(fit_brms, \n  variables = list(advice_present = 0:1), \n  re_formula = NA, type = \"response\") %>% \n  hypotheses(hypothesis = c(\"b2 - b1 = 0\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n    Term Estimate 2.5 % 97.5 %\n b2-b1=0    0.177 0.144   0.21\n\nColumns: term, estimate, conf.low, conf.high \nType:  response \n```\n\n\n:::\n:::\n\n\n## Option 2\n\n\n::: {.cell}\n\n```{.r .cell-code}\navg_comparisons(fit_brms, \n  variables = \"advice_present\", \n  re_formula = NA, type = \"response\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n           Term          Contrast Estimate 2.5 % 97.5 %\n advice_present mean(1) - mean(0)    0.177 0.144   0.21\n\nColumns: term, contrast, estimate, conf.low, conf.high, predicted_lo, predicted_hi, predicted, tmp_idx \nType:  response \n```\n\n\n:::\n:::\n\n\n## Option 3\n\n\n::: {.cell}\n\n```{.r .cell-code}\npredictions(fit_brms,\n  newdata = datagrid(advice_present = 0:1),\n  re_formula = NA, type = \"response\") %>% \n  hypotheses(hypothesis = c(\"b2 - b1 = 0\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n    Term Estimate 2.5 % 97.5 %\n b2-b1=0    0.177 0.144   0.21\n\nColumns: term, estimate, conf.low, conf.high \nType:  response \n```\n\n\n:::\n:::\n\n\n## Option 4\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncomparisons(fit_brms,\n  newdata = datagrid(advice_present = 1),\n  re_formula = NA, type = \"response\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n           Term Contrast advice_present Estimate 2.5 % 97.5 %    subject   item\n advice_present    1 - 0              1    0.177 0.144   0.21 subject001 item01\n\nColumns: rowid, term, contrast, estimate, conf.low, conf.high, advice_present, predicted_lo, predicted_hi, predicted, tmp_idx, subject, item, y_bin \nType:  response \n```\n\n\n:::\n:::\n\n\n:::\n\n\n### Treatment effect averaged across the actually observed persons and items\n\n**Estimand:**\n\n$$\n\\begin{aligned}\n\\frac{1}{S \\cdot I} \\sum_{s}  \\sum_{i} & \\quad P(Y = 1 | advice\\_present = 1, u_{0s}, u_{1s}, u_{0i}) \\\\\n& \\quad - P(Y = 1 | advice\\_present = 0, u_{0s}, u_{1s}, u_{0i})\n\\end{aligned}\n$$\n\n#### lme4\n\n::: {.panel-tabset group=\"package2\"}\n\n## Option 1\n\n\n::: {.cell}\n\n```{.r .cell-code}\navg_predictions(fit_lme4, \n  newdata = datagrid(advice_present = 0:1, subject = unique, item = unique),\n  by = \"advice_present\",\n  re.form = NULL, type = \"response\") %>% \n  hypotheses(hypothesis = c(\"b2 - b1 = 0\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: For this model type, `marginaleffects` only takes into account the\n  uncertainty in fixed-effect parameters. You can use the `re.form=NA`\n  argument to acknowledge this explicitly and silence this warning.\nWarning: For this model type, `marginaleffects` only takes into account the\n  uncertainty in fixed-effect parameters. You can use the `re.form=NA`\n  argument to acknowledge this explicitly and silence this warning.\nWarning: For this model type, `marginaleffects` only takes into account the\n  uncertainty in fixed-effect parameters. You can use the `re.form=NA`\n  argument to acknowledge this explicitly and silence this warning.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n    Term Estimate Std. Error    z Pr(>|z|)    S 2.5 % 97.5 %\n b2-b1=0    0.167     0.0162 10.3   <0.001 80.1 0.135  0.199\n\nColumns: term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \nType:  response \n```\n\n\n:::\n:::\n\n\n## Option 2\n\n\n::: {.cell}\n\n```{.r .cell-code}\navg_comparisons(fit_lme4, \n  variables = \"advice_present\", \n  re.form = NULL, type = \"response\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: For this model type, `marginaleffects` only takes into account the\n  uncertainty in fixed-effect parameters. You can use the `re.form=NA`\n  argument to acknowledge this explicitly and silence this warning.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n           Term          Contrast Estimate Std. Error    z Pr(>|z|)    S 2.5 %\n advice_present mean(1) - mean(0)    0.167     0.0162 10.3   <0.001 80.1 0.135\n 97.5 %\n  0.199\n\nColumns: term, contrast, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high, predicted_lo, predicted_hi, predicted \nType:  response \n```\n\n\n:::\n:::\n\n\n:::\n\n\n#### brms\n\n::: {.panel-tabset group=\"package2\"}\n\n## Option 1\n\n\n::: {.cell}\n\n```{.r .cell-code}\navg_predictions(fit_brms, \n  newdata = datagrid(advice_present = 0:1, subject = unique, item = unique),\n  by = \"advice_present\",\n  re_formula = NULL, type = \"response\") %>% \n  hypotheses(hypothesis = c(\"b2 - b1 = 0\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n    Term Estimate 2.5 % 97.5 %\n b2-b1=0    0.164 0.139   0.19\n\nColumns: term, estimate, conf.low, conf.high \nType:  response \n```\n\n\n:::\n:::\n\n\n## Option 2\n\n\n::: {.cell}\n\n```{.r .cell-code}\navg_comparisons(fit_brms, \n  variables = \"advice_present\", \n  re_formula = NULL, type = \"response\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n           Term          Contrast Estimate 2.5 % 97.5 %\n advice_present mean(1) - mean(0)    0.164 0.139   0.19\n\nColumns: term, contrast, estimate, conf.low, conf.high, predicted_lo, predicted_hi, predicted, tmp_idx \nType:  response \n```\n\n\n:::\n:::\n\n\n:::\n\n\n### Treatment effect averaged across new persons and new items\n\n**Estimand:**\n\n$$\n\\begin{aligned}\n\\frac{1}{S_{new} \\cdot I_{new}} \\sum_{s_{new}}  \\sum_{i_{new}} & \\quad P(Y = 1 | advice\\_present = 1, u_{0s_{new}}, u_{1s_{new}}, u_{0i_{new}}) \\\\\n& \\quad - P(Y = 1 | advice\\_present = 0, u_{0s_{new}}, u_{1s_{new}}, u_{0i_{new}})\n\\end{aligned}\n$$\n\n#### lme4\n\n::: {.callout-warning}\nThis cannot actually be done with *lme4*, which cannot sample new subjects or items (at least not with its `predict` function; it would work with the `simulate`function in *lme4*, which cannot be used by the *marginaleffects* package)! The code below produces the same results as the *lme4* estimates for the **Treatment effect for an average person and an average item**!\n:::\n\n::: {.panel-tabset group=\"package3\"}\n\n## Option 1\n\n\n::: {.cell}\n\n```{.r .cell-code}\navg_predictions(fit_lme4, \n  newdata = datagrid(advice_present = 0:1, subject = -1:-50, item = -1:-20),\n  by = \"advice_present\",\n  re.form = NULL, allow.new.levels = TRUE, \n  type = \"response\") %>% \n  hypotheses(hypothesis = c(\"b2 - b1 = 0\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: For this model type, `marginaleffects` only takes into account the\n  uncertainty in fixed-effect parameters. You can use the `re.form=NA`\n  argument to acknowledge this explicitly and silence this warning.\nWarning: For this model type, `marginaleffects` only takes into account the\n  uncertainty in fixed-effect parameters. You can use the `re.form=NA`\n  argument to acknowledge this explicitly and silence this warning.\nWarning: For this model type, `marginaleffects` only takes into account the\n  uncertainty in fixed-effect parameters. You can use the `re.form=NA`\n  argument to acknowledge this explicitly and silence this warning.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n    Term Estimate Std. Error    z Pr(>|z|)    S 2.5 % 97.5 %\n b2-b1=0    0.176     0.0166 10.6   <0.001 84.8 0.143  0.208\n\nColumns: term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \nType:  response \n```\n\n\n:::\n:::\n\n\n## Option 2\n\n\n::: {.cell}\n\n```{.r .cell-code}\navg_comparisons(fit_lme4,\n  variables = \"advice_present\",\n  newdata = datagrid(advice_present = 0:1, subject = -1:-50, item = -1:-20),\n  re.form = NULL, allow.new.levels = TRUE, \n  type = \"response\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: For this model type, `marginaleffects` only takes into account the\n  uncertainty in fixed-effect parameters. You can use the `re.form=NA`\n  argument to acknowledge this explicitly and silence this warning.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n           Term          Contrast Estimate Std. Error    z Pr(>|z|)    S 2.5 %\n advice_present mean(1) - mean(0)    0.176     0.0166 10.6   <0.001 84.8 0.143\n 97.5 %\n  0.208\n\nColumns: term, contrast, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high, predicted_lo, predicted_hi, predicted \nType:  response \n```\n\n\n:::\n:::\n\n\n:::\n\n\n#### brms\n\n::: {.callout-important}\nThe option `sample_new_levels = \"gaussian\"` specifies that for new factor levels, random effects are drawn from the estimated (multivariate) normal distribution of random effects. Note that this setting is **not the default**! Also note that `allow_new_levels = TRUE` will make the *brms* predictions for new levels **non-deterministic**!\n:::\n\n::: {.callout-warning}\nThe following two options produce slightly different results, and I currently do not know why! It might only be randomness introduced by different seeds.\n:::\n\n::: {.panel-tabset group=\"package3\"}\n\n## Option 1\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\navg_predictions(fit_brms, \n  newdata = datagrid(advice_present = 0:1, subject = -1:-50, item = -1:-20),\n  by = \"advice_present\",\n  re_formula = NULL, allow_new_levels = TRUE, sample_new_levels = \"gaussian\", \n  type = \"response\") %>% \n  hypotheses(hypothesis = c(\"b2 - b1 = 0\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n    Term Estimate 2.5 % 97.5 %\n b2-b1=0    0.162 0.121  0.203\n\nColumns: term, estimate, conf.low, conf.high \nType:  response \n```\n\n\n:::\n:::\n\n\n## Option 2\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\navg_comparisons(fit_brms,\n  variables = \"advice_present\",\n  newdata = datagrid(advice_present = 0:1, subject = -1:-50, item = -1:-20),\n  re_formula = NULL, allow_new_levels = TRUE, sample_new_levels = \"gaussian\", \n  type = \"response\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n           Term          Contrast Estimate 2.5 % 97.5 %\n advice_present mean(1) - mean(0)    0.163 0.122  0.203\n\nColumns: term, contrast, estimate, conf.low, conf.high, predicted_lo, predicted_hi, predicted, tmp_idx \nType:  response \n```\n\n\n:::\n:::\n\n\n:::\n\n### Treatment effect averaged across new persons but the actually observed items\n\n**Estimand:**\n\n$$\n\\begin{aligned}\n\\frac{1}{S_{new} \\cdot I} \\sum_{s_{new}}  \\sum_{i} & \\quad P(Y = 1 | advice\\_present = 1, u_{0s_{new}}, u_{1s_{new}}, u_{0i}) \\\\\n& \\quad - P(Y = 1 | advice\\_present = 0, u_{0s_{new}}, u_{1s_{new}}, u_{0i})\n\\end{aligned}\n$$\n\n#### lme4\n\n::: {.callout-warning}\nBecause *lme4* cannot sample new levels, what it actually does for a new subject is to set all random effects for the subject to 0.\n:::\n\n::: {.panel-tabset group=\"package4\"}\n\n## Option 1\n\n\n::: {.cell}\n\n```{.r .cell-code}\navg_predictions(fit_lme4, \n  newdata = datagrid(advice_present = 0:1, subject = -1:-50, item = unique),\n  by = \"advice_present\",\n  re.form = NULL, allow.new.levels = TRUE, \n  type = \"response\") %>% \n  hypotheses(hypothesis = c(\"b2 - b1 = 0\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: For this model type, `marginaleffects` only takes into account the\n  uncertainty in fixed-effect parameters. You can use the `re.form=NA`\n  argument to acknowledge this explicitly and silence this warning.\nWarning: For this model type, `marginaleffects` only takes into account the\n  uncertainty in fixed-effect parameters. You can use the `re.form=NA`\n  argument to acknowledge this explicitly and silence this warning.\nWarning: For this model type, `marginaleffects` only takes into account the\n  uncertainty in fixed-effect parameters. You can use the `re.form=NA`\n  argument to acknowledge this explicitly and silence this warning.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n    Term Estimate Std. Error    z Pr(>|z|)    S 2.5 % 97.5 %\n b2-b1=0    0.177     0.0164 10.8   <0.001 87.7 0.145  0.209\n\nColumns: term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \nType:  response \n```\n\n\n:::\n:::\n\n\n## Option 2\n\n\n::: {.cell}\n\n```{.r .cell-code}\navg_comparisons(fit_lme4,\n  variables = \"advice_present\",\n  newdata = datagrid(advice_present = 0:1, subject = -1:-50, item = unique),\n  re.form = NULL, allow.new.levels = TRUE, \n  type = \"response\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: For this model type, `marginaleffects` only takes into account the\n  uncertainty in fixed-effect parameters. You can use the `re.form=NA`\n  argument to acknowledge this explicitly and silence this warning.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n           Term          Contrast Estimate Std. Error    z Pr(>|z|)    S 2.5 %\n advice_present mean(1) - mean(0)    0.177     0.0164 10.8   <0.001 87.7 0.145\n 97.5 %\n  0.209\n\nColumns: term, contrast, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high, predicted_lo, predicted_hi, predicted \nType:  response \n```\n\n\n:::\n:::\n\n\n:::\n\n\n\n#### brms\n\n::: {.callout-warning}\nThe following two options produce slightly different results, and I currently do not know why! It might only be randomness introduced by different seeds.\n:::\n\n::: {.panel-tabset group=\"package4\"}\n\n## Option 1\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\navg_predictions(fit_brms, \n  newdata = datagrid(advice_present = 0:1, subject = -1:-50, item = unique),\n  by = \"advice_present\",\n  re_formula = NULL, allow_new_levels = TRUE, sample_new_levels = \"gaussian\", \n  type = \"response\") %>% \n  hypotheses(hypothesis = c(\"b2 - b1 = 0\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n    Term Estimate 2.5 % 97.5 %\n b2-b1=0    0.163 0.126  0.199\n\nColumns: term, estimate, conf.low, conf.high \nType:  response \n```\n\n\n:::\n:::\n\n\n## Option 2\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\navg_comparisons(fit_brms,\n  variables = \"advice_present\",\n  newdata = datagrid(advice_present = 0:1, subject = -1:-50, item = unique),\n  re_formula = NULL, allow_new_levels = TRUE, sample_new_levels = \"gaussian\", \n  type = \"response\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n           Term          Contrast Estimate 2.5 % 97.5 %\n advice_present mean(1) - mean(0)    0.163 0.125  0.198\n\nColumns: term, contrast, estimate, conf.low, conf.high, predicted_lo, predicted_hi, predicted, tmp_idx \nType:  response \n```\n\n\n:::\n:::\n\n\n:::\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}